<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>synchronized</title>
    <link href="/2023/10/19/synchronized/"/>
    <url>/2023/10/19/synchronized/</url>
    
    <content type="html"><![CDATA[<h3 id="1-多线程中-synchronized-锁升级的原理是什么？"><a href="#1-多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="1. 多线程中 synchronized 锁升级的原理是什么？"></a>1. 多线程中 synchronized 锁升级的原理是什么？</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，<a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=jvm&spm=1001.2101.3001.7020">jvm</a> 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h3 id="2-什么是死锁？"><a href="#2-什么是死锁？" class="headerlink" title="2. 什么是死锁？"></a>2. 什么是死锁？</h3><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><h3 id="3-怎么防止死锁？"><a href="#3-怎么防止死锁？" class="headerlink" title="3. 怎么防止死锁？"></a>3. 怎么防止死锁？</h3><ul><li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li><li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</li><li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li><li>尽量减少同步的代码块。</li></ul><h3 id="4-ThreadLocal-是什么？有哪些使用场景？"><a href="#4-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="4. ThreadLocal 是什么？有哪些使用场景？"></a>4. ThreadLocal 是什么？有哪些使用场景？</h3><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><h3 id="5-说一下-synchronized-底层实现原理？"><a href="#5-说一下-synchronized-底层实现原理？" class="headerlink" title="5. 说一下 synchronized 底层实现原理？"></a>5. 说一下 synchronized 底层实现原理？</h3><p>synchronized 是由一对 monitorenter&#x2F;monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p><h3 id="6-synchronized-和-volatile-的区别是什么？"><a href="#6-synchronized-和-volatile-的区别是什么？" class="headerlink" title="6. synchronized 和 volatile 的区别是什么？"></a>6. synchronized 和 volatile 的区别是什么？</h3><ul><li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li></ul><h3 id="7-synchronized-和-Lock-有什么区别？"><a href="#7-synchronized-和-Lock-有什么区别？" class="headerlink" title="7. synchronized 和 Lock 有什么区别？"></a>7. synchronized 和 Lock 有什么区别？</h3><ul><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><h3 id="8-synchronized-和-ReentrantLock-区别是什么？"><a href="#8-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="8. synchronized 和 ReentrantLock 区别是什么？"></a>8. synchronized 和 ReentrantLock 区别是什么？</h3><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p><p>主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Iterator</title>
    <link href="/2023/10/19/Iterator/"/>
    <url>/2023/10/19/Iterator/</url>
    
    <content type="html"><![CDATA[<h3 id="1-迭代器-Iterator-是什么？"><a href="#1-迭代器-Iterator-是什么？" class="headerlink" title="1. 迭代器 Iterator 是什么？"></a>1. 迭代器 Iterator 是什么？</h3><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合<a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020">框架</a>中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><h3 id="2-Iterator-怎么使用？有什么特点？"><a href="#2-Iterator-怎么使用？有什么特点？" class="headerlink" title="2. Iterator 怎么使用？有什么特点？"></a>2. Iterator 怎么使用？有什么特点？</h3><p>Iterator 使用代码如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">List&lt;<span class="hljs-type">String</span>&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br><br><br><span class="hljs-keyword">Iterator</span>&lt;<span class="hljs-type">String</span>&gt; it = list. <span class="hljs-keyword">iterator</span>();<br><br><br><br><br><span class="hljs-type">String</span> obj = it. <span class="hljs-keyword">next</span>();<br><br><br>System. out. println(obj);<br></code></pre></td></tr></table></figure><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h3 id="3-Iterator-和-ListIterator-有什么区别？"><a href="#3-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="3. Iterator 和 ListIterator 有什么区别？"></a>3. Iterator 和 ListIterator 有什么区别？</h3><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。</li><li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBootApplication</title>
    <link href="/2023/10/16/SpringBootApplication/"/>
    <url>/2023/10/16/SpringBootApplication/</url>
    
    <content type="html"><![CDATA[<p><strong>@SpringBootApplication包含的三个注解及其含义</strong></p><p><strong>第一个：@SpringBootConfiguration（在这个类的源码中又有一个Configuration的注解）</strong></p><p>@Configuration这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，读取其中的配置信息，而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。</p><p><strong>第二个：@EnableAutoConfiguration</strong></p><p>开启自动配置，告诉SpringBoot基于所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖，此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。</p><p><strong>第三个：@ComponentScan</strong></p><p>配置组件扫描的指令</p><p>提供了类似与<a href="context:component-scan">context:component-scan</a>标签的作用</p><p>通过basePackageClasses或者basePackages属性来指定要扫描的包。</p><p>如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包</p><p>而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，</p><p>因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interceptor</title>
    <link href="/2023/10/15/interceptor/"/>
    <url>/2023/10/15/interceptor/</url>
    
    <content type="html"><![CDATA[<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> LoginInterceptor implements HandlerInterceptor &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> preHandle(HttpServletRequest request, HttpServletResponse response, <span class="hljs-keyword">Object</span> <span class="hljs-keyword">handler</span>)<br>            throws <span class="hljs-keyword">Exception</span> &#123;<br>        HttpSession <span class="hljs-keyword">session</span> = request.getSession();<br>        <span class="hljs-keyword">Object</span> <span class="hljs-keyword">admin</span> = <span class="hljs-keyword">session</span>.getAttribute(&quot;admin&quot;);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">admin</span> == <span class="hljs-keyword">null</span>) &#123;<br>            String <span class="hljs-keyword">header</span> = request.getHeader(&quot;X-Requested-With&quot;);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">header</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">header</span>.equals(&quot;XMLHttpRequest&quot;)) &#123;<br>                ObjectMapper mapper = <span class="hljs-built_in">new</span> ObjectMapper();<br>                RespBean respBean = RespBean.error(&quot;请重新登录&quot;);<br>                mapper.writeValue(response.getOutputStream(),respBean);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                response.sendRedirect(request.getContextPath() + &quot;/&quot;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在WebConfig配置拦截器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//配置拦截器</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addInterceptors</span>(<span class="hljs-params">InterceptorRegistry registry</span>) &#123;<br>    registry.<span class="hljs-title function_">addInterceptor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>            .<span class="hljs-title function_">addPathPatterns</span>(<span class="hljs-string">&quot;/admin/**&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-1-过滤器Filter和拦截器Interceptor的区别"><a href="#1-1-过滤器Filter和拦截器Interceptor的区别" class="headerlink" title="1.1. *过滤器Filter和拦截器Interceptor的区别*"></a><strong>1.1.</strong> <em><strong>*过滤器Filter和拦截器Interceptor的区别*</strong></em></h2><p>过滤器 和 拦截器 均体现了AOP的编程思想，都可以实现诸如日志记录、登录鉴权等功能，但二者的不同点也是比较多的</p><p>1、 实现原理不同</p><p>过滤器 是基于函数回调的，拦截器 则是基于Java的反射机制（动态代理）实现的。</p><p>2、 使用范围不同</p><p>过滤器 实现的是 javax.servlet.Filter 接口，而这个接口是在Servlet规范中定义的，也就是说过滤器Filter 的使用要依赖于Tomcat等容器，导致它只能在web程序中使用。</p><p>拦截器(Interceptor) 它是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。不仅能应用在web程序中，还可以使用在其他地方</p><p>3、 触发时机不同</p><p>过滤器 和 拦截器的触发时机也不同，我们看下边这张图。</p><p><img src="/images/interceptor.jpg" alt="img"> </p><p>执行顺序 ：过滤前 - 拦截前 - Controller处理 - 拦截后 - 过滤后</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
